{"version":3,"file":"4141.00e61b3a22599e7f5710.chunk.js","mappings":"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","sources":["webpack://quilt-navigator/./app/containers/StoryBook/JsonEditor.tsx","webpack://quilt-navigator/./app/containers/StoryBook/StoryBook.tsx","webpack://quilt-navigator/./app/utils/json-schema/json-schema.ts"],"sourcesContent":["import * as React from 'react'\nimport * as M from '@material-ui/core'\n\nimport JsonEditor from 'components/JsonEditor'\nimport * as jsonSchema from 'utils/json-schema'\nimport { JsonValue, ValidationErrors } from 'components/JsonEditor/constants'\n\nconst schema = {\n  type: 'object',\n  properties: {\n    a: { type: 'number' },\n    b: { type: 'number' },\n  },\n}\nconst validate = jsonSchema.makeSchemaValidator(schema)\n\nexport default function JsonEditorBook() {\n  const [value, setValue] = React.useState<JsonValue>({\n    a: '123',\n    b: 123,\n  })\n  const [errors, setErrors] = React.useState<ValidationErrors>(() => validate(value))\n  const onChange = React.useCallback((json) => {\n    setErrors(validate(json))\n    setValue(json)\n  }, [])\n  return (\n    <M.Container maxWidth=\"lg\">\n      <M.Box bgcolor=\"common.white\" py={2}>\n        <JsonEditor errors={errors} value={value} onChange={onChange} schema={schema} />\n      </M.Box>\n    </M.Container>\n  )\n}\n","import * as React from 'react'\n\nimport Layout from 'components/Layout'\n\nimport JsonEditorBook from './JsonEditor'\n\nexport default function StoryBook() {\n  return <Layout pre={<JsonEditorBook />} />\n}\n","import Ajv, { SchemaObject, ErrorObject, Options } from 'ajv'\nimport addFormats from 'ajv-formats'\nimport * as dateFns from 'date-fns'\nimport * as R from 'ramda'\n\ntype CompoundCondition = 'anyOf' | 'oneOf' | 'not' | 'allOf'\n\n// TODO: use more detailed `Ajv.JSONSchemaType` instead\nexport type JsonSchema = SchemaObject\n\nexport const isSchemaArray = (optSchema?: JsonSchema) => optSchema?.type === 'array'\n\nexport const isSchemaObject = (optSchema?: JsonSchema) => optSchema?.type === 'object'\n\nconst isSchemaString = (optSchema?: JsonSchema) => optSchema?.type === 'string'\n\nconst isSchemaNumber = (optSchema?: JsonSchema) => optSchema?.type === 'number'\n\nconst isSchemaInteger = (optSchema?: JsonSchema) => optSchema?.type === 'integer'\n\nexport const isSchemaBoolean = (optSchema?: JsonSchema) => optSchema?.type === 'boolean'\n\nconst isSchemaNull = (optSchema?: JsonSchema) => optSchema?.type === 'null'\n\nexport const isSchemaEnum = (optSchema?: JsonSchema) => !!optSchema?.enum\n\nexport const isSchemaOneOf = (optSchema?: JsonSchema) => !!optSchema?.oneOf\n\nexport const isSchemaAnyOf = (optSchema?: JsonSchema) => !!optSchema?.anyOf\n\nexport const isSchemaAllOf = (optSchema?: JsonSchema) => !!optSchema?.allOf\n\nconst isSchemaConst = (optSchema?: JsonSchema) => !!optSchema?.const\n\nfunction isSchemaCompound(optSchema?: JsonSchema) {\n  if (!optSchema) return false\n  return ['anyOf', 'oneOf', 'not', 'allOf'].some(\n    (key) => optSchema[key as 'anyOf' | 'oneOf' | 'not' | 'allOf'],\n  )\n}\n\nconst isSchemaReference = (optSchema: JsonSchema) => !!optSchema?.$ref\n\nexport const isNestedType = R.either(isSchemaArray, isSchemaObject)\n\nfunction compoundTypeToHumanString(\n  optSchema: JsonSchema,\n  condition: CompoundCondition,\n  divider: string,\n): string {\n  if (!isSchemaCompound(optSchema)) return ''\n\n  return optSchema[condition]!.map(schemaTypeToHumanString)\n    .filter((v: string) => v !== 'undefined') // NOTE: sic, see default case of `schemaTypeToHumanString`\n    .join(divider)\n}\n\nexport function schemaTypeToHumanString(optSchema?: JsonSchema) {\n  if (!optSchema) return ''\n  return R.cond<JsonSchema, string>([\n    [isSchemaEnum, () => 'enum'],\n    [isSchemaConst, () => 'const'],\n    [isSchemaBoolean, () => 'boolean'],\n    [isSchemaNull, () => 'null'],\n    // NOTE: enum and const can be string too,\n    //       that's why they are first\n    [\n      R.propOr('', 'type'),\n      () =>\n        Array.isArray(optSchema.type)\n          ? optSchema.type.join('|')\n          : (optSchema.type as string),\n    ],\n    [isSchemaAnyOf, () => compoundTypeToHumanString(optSchema, 'anyOf', '|')],\n    [isSchemaOneOf, () => compoundTypeToHumanString(optSchema, 'oneOf', '|')],\n    [isSchemaAllOf, () => compoundTypeToHumanString(optSchema, 'allOf', '&')],\n    [isSchemaCompound, () => 'compound'],\n    [isSchemaReference, () => '$ref'],\n    [R.T, () => 'undefined'],\n  ])(optSchema)\n}\n\nfunction doesTypeMatchCompoundSchema(\n  value: any,\n  condition: CompoundCondition,\n  optSchema?: JsonSchema,\n): boolean {\n  if (!optSchema) return true\n\n  if (!isSchemaCompound(optSchema)) return false\n\n  return optSchema[condition]!.filter(R.has('type')).some((subSchema: JsonSchema) =>\n    doesTypeMatchSchema(value, subSchema),\n  )\n}\n\n// Purpose is to find mismatch explicitly\n// TODO: rename and redesign function to avoid \"if no schema -> return true aka 'type matches schema'\"\nexport function doesTypeMatchSchema(value: any, optSchema?: JsonSchema): boolean {\n  if (!optSchema) return true\n  return R.cond<JsonSchema, boolean>([\n    [isSchemaEnum, () => R.includes(value, R.propOr([], 'enum', optSchema))],\n    [\n      (s) => Array.isArray(s?.type),\n      () =>\n        (optSchema.type as JsonSchema[]).some((subSchema) =>\n          doesTypeMatchSchema(value, subSchema),\n        ),\n    ],\n    [isSchemaAnyOf, () => doesTypeMatchCompoundSchema(value, 'anyOf', optSchema)],\n    [isSchemaOneOf, () => doesTypeMatchCompoundSchema(value, 'oneOf', optSchema)],\n    [isSchemaAllOf, () => doesTypeMatchCompoundSchema(value, 'allOf', optSchema)],\n    [isSchemaArray, () => Array.isArray(value)],\n    [isSchemaObject, () => R.is(Object, value)],\n    [isSchemaString, () => R.is(String, value)],\n    [isSchemaInteger, () => Number.isInteger(value)],\n    [isSchemaNumber, () => R.is(Number, value)],\n    [isSchemaNull, () => R.equals(null, value)],\n    [isSchemaBoolean, () => R.is(Boolean, value)],\n    [R.T, R.T], // It's not a user's fault that we can't handle the type\n  ])(optSchema)\n}\n\nexport const EMPTY_SCHEMA: JsonSchema = {}\n\nexport function makeSchemaValidator(\n  optSchema?: JsonSchema,\n  optSchemas?: JsonSchema[],\n  ajvOptions?: Options,\n): (obj?: any) => (Error | ErrorObject)[] {\n  let mainSchema = R.clone(optSchema || EMPTY_SCHEMA)\n  if (!mainSchema.$id) {\n    // Make further code more universal by using one format: `id` → `$id`\n    if (mainSchema.id) {\n      mainSchema = R.pipe(R.assoc('$id', mainSchema.id), R.dissoc('id'))(mainSchema)\n    } else {\n      mainSchema = R.assoc('$id', 'main_schema', mainSchema)\n    }\n  }\n  const schemas = optSchemas ? [mainSchema, ...optSchemas] : [mainSchema]\n\n  const { $id } = schemas[0]\n  const options: Options = {\n    allErrors: true,\n    schemaId: '$id',\n    schemas,\n    useDefaults: true,\n    ...ajvOptions,\n  }\n\n  try {\n    const ajv = new Ajv(options)\n    addFormats(ajv, ['date', 'regex', 'uri'])\n    ajv.addKeyword('dateformat')\n\n    // TODO: fail early, return Error instead of callback\n    if (!$id) return () => [new Error('$id is not provided')]\n\n    return (obj: any): ErrorObject[] => {\n      ajv.validate($id, R.clone(obj))\n      // TODO: add custom errors\n      return ajv.errors || []\n    }\n  } catch (e) {\n    // TODO: fail early if Ajv options are incorrect, return Error instead of callback\n    // TODO: add custom errors\n    return () => (e instanceof Error ? [e] : []) as Error[]\n  }\n}\n\n// TODO: make general purpose function like reduce,\n//       do \"prefill Value\" at callback,\n//       and use it for iterating Schema in JsonEditor/State\nfunction scanSchemaAndPrefillValues(\n  getValue: (s?: JsonSchema) => any,\n  value: Record<string, any>,\n  optSchema?: JsonSchema,\n): Record<string, any> {\n  if (!optSchema) return value\n\n  if (!optSchema?.properties) return value\n\n  return Object.keys(optSchema.properties).reduce((memo, key) => {\n    const valueItem = value === undefined ? undefined : value[key]\n\n    // don't touch user's primitive value\n    if (valueItem && !R.is(Object, valueItem)) return memo\n\n    const schemaItem = R.propOr({}, key, optSchema.properties) as JsonSchema\n\n    if (schemaItem.properties)\n      return R.assoc(\n        key,\n        scanSchemaAndPrefillValues(getValue, valueItem, schemaItem),\n        memo,\n      )\n\n    if (schemaItem.items && Array.isArray(valueItem))\n      return R.assoc(\n        key,\n        valueItem.map((v) => scanSchemaAndPrefillValues(getValue, v, schemaItem.items)),\n        memo,\n      )\n\n    const preDefinedValue = getValue(schemaItem)\n    if (preDefinedValue) return R.assoc(key, preDefinedValue, memo)\n\n    return memo\n  }, value)\n}\n\nexport function getDefaultValue(optSchema?: JsonSchema): any {\n  if (!optSchema) return undefined\n\n  if (optSchema.default !== undefined) return optSchema.default\n\n  try {\n    if (optSchema.format === 'date' && optSchema.dateformat)\n      return dateFns.format(new Date(), optSchema.dateformat)\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error(error)\n  }\n\n  return undefined\n}\n\nexport function makeSchemaDefaultsSetter(optSchema?: JsonSchema) {\n  return (obj: any) => scanSchemaAndPrefillValues(getDefaultValue, obj, optSchema)\n}\n"],"names":["schema","type","properties","a","b","validate","JsonEditorBook","value","setValue","errors","setErrors","onChange","json","maxWidth","bgcolor","py","JsonEditor","StoryBook","Layout","pre","isSchemaArray","optSchema","isSchemaObject","isSchemaString","isSchemaNumber","isSchemaInteger","isSchemaBoolean","isSchemaNull","isSchemaEnum","enum","isSchemaOneOf","oneOf","isSchemaAnyOf","anyOf","isSchemaAllOf","allOf","isSchemaConst","const","isSchemaCompound","some","key","isSchemaReference","$ref","isNestedType","compoundTypeToHumanString","condition","divider","map","schemaTypeToHumanString","filter","v","join","Array","isArray","doesTypeMatchCompoundSchema","subSchema","doesTypeMatchSchema","s","Object","String","Number","isInteger","Boolean","EMPTY_SCHEMA","makeSchemaValidator","optSchemas","ajvOptions","mainSchema","$id","id","schemas","options","allErrors","schemaId","useDefaults","addKeyword","obj","Error","e","scanSchemaAndPrefillValues","getValue","keys","reduce","memo","valueItem","undefined","schemaItem","items","preDefinedValue","getDefaultValue","default","format","dateformat","Date","error","console","makeSchemaDefaultsSetter"],"sourceRoot":""}