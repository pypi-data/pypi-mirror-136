{"version":3,"sources":["webpack://@deshaw/jupyterlab-pyflyby/./lib/cellUtils.js","webpack://@deshaw/jupyterlab-pyflyby/./lib/constants.js","webpack://@deshaw/jupyterlab-pyflyby/./lib/handler.js","webpack://@deshaw/jupyterlab-pyflyby/./lib/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAA4C;AACE;AAC9C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uBAAuB,0DAAO;AAC9B,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kCAAkC,QAAQ;AAC1C;AACA,yBAAyB,8DAAsB,IAAI,8DAAsB;AACzE;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpGA;AACO;AACA;AACA;AACA;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACR+C;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD;AACA,qBAAqB,+EAA6B;AAClD,uBAAuB,8DAAW;AAClC;AACA;AACA;AACA,yBAAyB,8EAA4B;AACrD;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACb;AACiB;AACK;AACjC;AACJ;AAC1B;AACoD;AAC8C;AAC3D;AACvC,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;AACA;AACA;AACA,sBAAsB,iEAAe;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,+BAA+B,sEAAuB,CAAC,0DAAO;AAC9D;AACA,2CAA2C,wDAAgB;AAC3D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAQ,CAAC,0DAAO;AAC/C;AACA;AACA,uBAAuB,uDAAW;AAClC;AACA;AACA;AACA,+BAA+B,yDAAiB,CAAC,MAAM,uDAAe,CAAC;AACvE;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,gEAAwB;AAC/C;AACA,mCAAmC,wDAAgB;AACnD,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sEAAuB,CAAC,0DAAO;AAChE;AACA,2CAA2C,wDAAgB;AAC3D,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC,oEAA4B;AACjE;AACA;AACA;AACA;AACA,0BAA0B,oEAA4B;AACtD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB,oEAA4B;AACjD;AACA;AACA;AACA;AACA,qBAAqB,0DAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,2BAA2B,qEAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,EAAE;AAC7D;AACA,gDAAgD,oEAA4B;AAC5E;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAA4B;AAChD;AACA;AACA;AACA;AACA,2DAA2D,EAAE;AAC7D;AACA,kCAAkC,0DAAkB;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C,iCAAiC,sEAAuB,CAAC,0DAAO;AAChE;AACA,2CAA2C,wDAAgB;AAC3D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAU;AAC1C;AACA;AACA;AACA;AACA,cAAc,oDAAU,qBAAqB,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAU;AACxB;AACA;AACA;AACA;AACA,sBAAsB,sDAAsD;AAC5E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAmB;AAC7C,IAAI,0DAAmB;AACvB;AACA;AACA,QAAQ,0DAAmB,OAAO,2EAA2E,mBAAmB,gDAAgD;AAChL;AACA;AACA,IAAI,0DAAmB;AACvB,IAAI,0DAAmB;AACvB,IAAI,0DAAmB,SAAS;AAChC;AACA;AACA;AACA;AACA,SAAS,EAAE;AACX,IAAI,0DAAmB;AACvB;AACA;AACA;AACA,eAAe,yEAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAU;AACnD;AACA;AACA;AACA,4BAA4B,iEAAe;AAC3C;AACA,6BAA6B;AAC7B,4BAA4B,qEAAmB,EAAE,0CAA0C;AAC3F;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC","file":"lib_index_js.7d16e2f492001d80a5f4.js","sourcesContent":["import { toArray } from '@lumino/algorithm';\nimport { PYFLYBY_END_MSG } from './constants';\n// FIXME: There's got to be a better Typescript solution\n// for distinguishing between members of a union type at runtime.\nexport const normalizeMultilineString = (source) => {\n    // Multilinestring can be an array of strings or string\n    return typeof source === 'string' ? source.split('\\n') : source;\n};\n/**\n * Very hacky code snippets to check if a line could be a code statement.\n * This could go wrong in a lot of ways and will just work in the\n * most common use cases.\n *\n * Expected to return true for import and code blocks\n */\nexport const couldBeCode = (line) => {\n    return (!(line.startsWith('#') ||\n        line.startsWith('\"\"\"') ||\n        line.trim() === '' ||\n        line.match(/^\\s.*$/)) || line.startsWith('%'));\n};\nexport const couldBeImportStatement = (line) => {\n    return (couldBeCode(line) &&\n        (line.includes('__future__') ||\n            line.split(' ').indexOf('import') !== -1 ||\n            line.includes('import_all_names')));\n};\n/**\n * It is safe to insert import only if current line is empty or doesn't start with a whitespace\n * */\nexport const safeToinsertImport = (line) => {\n    return line.trim() === '' || !line.match(/^\\s.*$/);\n};\n/**\n * Takes in a list of cell models and returns\n * the first *code* cell that\n *\n * - doesn't start with a line or cell magic\n *   (If it is line magic, should we inspect the following block of code?)\n * - isn't all import blocks and comments.\n *\n * @param cellModels - an array of cell models\n */\nexport const findCell = (cellModels) => {\n    const cellsArray = toArray(cellModels);\n    for (let i = 0; i < cellsArray.length; i++) {\n        const cellModel = cellsArray[i];\n        if (cellModel.type === 'code') {\n            const lines = normalizeMultilineString(cellModel.toJSON().source);\n            // FIXME: Deal with line magics better.\n            if (lines.length > 0 &&\n                !lines[0].startsWith('%') &&\n                !lines[0].startsWith('\"\"\"')) {\n                for (let j = 0; j < lines.length; j++) {\n                    if (couldBeCode(lines[j])) {\n                        return i;\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n};\n/**\n * Find the last import in a cell and return the position after that.\n *\n * If no imports exist, but code does, return 0.\n *\n * Else, it is likely an empty cell or a comment cell. Return -1.\n *\n * If we decide to reformat on each import, we can change this to\n * insert at the end of any code cell and just\n *\n * @param cell - a cell model\n */\nexport const findLinePos = (cell) => {\n    const lines = normalizeMultilineString(cell.toJSON().source);\n    for (let i = lines.length - 1; i >= 0; i--) {\n        // If PYFLYBY_END_MSG is found, add new import statement above it\n        if (lines[i] === PYFLYBY_END_MSG.substr(0, PYFLYBY_END_MSG.length - 1)) {\n            let pos = 0;\n            for (let j = 0; j < i - 1; j++) {\n                pos += lines[j].length + 1;\n            }\n            return pos;\n        }\n    }\n    for (let i = lines.length - 1; i >= 0; i--) {\n        if (couldBeImportStatement(lines[i]) &&\n            (i === lines.length - 1 || safeToinsertImport(lines[i + 1]))) {\n            let pos = 0;\n            for (let j = 0; j <= i; j++) {\n                pos += lines[j].length + 1;\n            }\n            return pos;\n        }\n    }\n    // Cell contains only comments or magics, so return -1.\n    // These imports will be moved to next cell\n    return -1;\n};\n","/** Constants */\nexport const PYFLYBY_CELL_TAG = 'pyflyby-cell';\nexport const PYFLYBY_START_MSG = '# THIS CELL WAS AUTO-GENERATED BY PYFLYBY\\n';\nexport const PYFLYBY_END_MSG = '# END AUTO-GENERATED BLOCK\\n';\nexport const PYFLYBY_COMMS = {\n    MISSING_IMPORTS: 'pyflyby.missing_imports',\n    FORMAT_IMPORTS: 'pyflyby.format_imports',\n    INIT: 'pyflyby.init_comms'\n};\n","import { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'pyflyby', // API Namespace\n    endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data = await response.text();\n    if (data.length > 0) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch (error) {\n            console.log('Not a JSON response body.', response);\n        }\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data;\n}\n","/**\n * Basic workflow -\n * 1. Connects to comms created by pyflyby\n * 2. Recieves imports added by pyflyby via PYFLYBY_COMMS.MISSING_IMPORTS\n * 3. Sends import statements recived in previous step to kernel for formatting using tidy_imports\n * 4. Recieves formatted imports via PYFLYBY_COMMS.FORMAT_IMPORTS which are added at suitable location in notebook\n *\n * Selecting cell where imports are added -\n * 1. First cell with 'pyflyby-cell' tag, if not  present then next step.\n * 2. First code cell which does not contain magic command\n * 3. If selected cell doesn't contain any import statement, add a new cell above the code cell.\n *\n * Selecting insert location inside the cell -\n * 1. If PYFLYBY_END_MSG is present, import is added above it.\n * 2. Added import after last import statement in code cell. Identifying import statement is\n *    is done by simple heuristics. This step can be shifted to pyflyby where python parser can be used to\n *    determine it accurately.\n */\n// Lumino imports\nimport { toArray, ArrayExt } from '@lumino/algorithm';\nimport { Widget } from '@lumino/widgets';\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { debug } from 'debug';\nimport React from 'react';\n// relative imports\nimport { findCell, findLinePos } from './cellUtils';\nimport { PYFLYBY_CELL_TAG, PYFLYBY_START_MSG, PYFLYBY_END_MSG, PYFLYBY_COMMS } from './constants';\nimport { requestAPI } from './handler';\nconst log = debug('PYFLYBY:');\nclass CommLock {\n    constructor() {\n        this.requestedLockCount = 0;\n        this.clearedLockCount = 0;\n        this._disable = {};\n        this.promise = { 0: Promise.resolve() };\n    }\n    enable(id) {\n        this.requestedLockCount++;\n        this.promise[id] = new Promise(resolve => {\n            this._disable[id] = resolve;\n            // Timeout and release the lock 1.5 sec after previous lock was released\n            setTimeout(() => {\n                var _a;\n                if ((_a = this._disable) === null || _a === void 0 ? void 0 : _a[id]) {\n                    this.disable();\n                }\n            }, 1500 * (this.requestedLockCount - this.clearedLockCount));\n        });\n    }\n    disable() {\n        this.clearedLockCount++;\n        this._disable[this.clearedLockCount]();\n        delete this._disable[this.clearedLockCount];\n    }\n}\n// We'd like to show the notification only once per session, not for each notebook\nlet _userWasNotified = false;\n/**\n * An extension that adds pyflyby integration to a single notebook widget\n */\nclass PyflyByWidget extends Widget {\n    constructor(context, panel, settingRegistry) {\n        super();\n        this._context = null;\n        this._sessionContext = null;\n        this._settings = null;\n        this._comms = {};\n        this._lock = new CommLock();\n        // get a reference to the settings registry\n        settingRegistry.load('@deshaw/jupyterlab-pyflyby:plugin').then((settings) => {\n            this._settings = settings;\n            const enabled = settings.get('enabled').user || settings.get('enabled').composite;\n            if (enabled) {\n                this._sessionContext.kernelChanged.connect(this._handleKernelChange, this);\n                this._sessionContext.statusChanged.connect(this._handleKernelStatusChange, this);\n            }\n        }, (err) => {\n            log('PYFLYBY extension has been disabled');\n        });\n        this._context = context;\n        this._sessionContext = context.sessionContext;\n    }\n    async _launchDialog(imports) {\n        /**\n         * Since we are making the first import, create a new dialog\n         */\n        const dialog = new Dialog({\n            title: 'PYFLYBY',\n            body: `PYFLYBY will be adding imports to the first code cell in the notebook.\n            To disable the PYFLYBY extension or to disable this notification in future, go\n            to Settings -> Advanced Settings Editor and choose PYFLYBY preferences tab`,\n            buttons: [Dialog.okButton()]\n        });\n        try {\n            await dialog.launch();\n            return imports;\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    /**\n     * All the logic related to finding the right cell\n     */\n    _findAndSetImportCoordinates() {\n        const { model } = this._context;\n        let pyflybyCellIndex = ArrayExt.findFirstIndex(toArray(model.cells), (cell, index) => {\n            const tags = cell.metadata.get('tags');\n            return !!(tags && tags.indexOf(PYFLYBY_CELL_TAG) !== -1);\n        });\n        /**\n         * Since the cell doesn't exist, we make one or, if the first\n         * code cell contains an import block, put it below that.\n         */\n        if (pyflybyCellIndex === -1) {\n            pyflybyCellIndex = findCell(toArray(model.cells));\n        }\n        let cell = model.cells.get(pyflybyCellIndex);\n        let position = findLinePos(model.cells.get(pyflybyCellIndex));\n        if (position === -1) {\n            cell = this._context.model.contentFactory.createCodeCell({\n                cell: {\n                    source: `${PYFLYBY_START_MSG}\\n\\n${PYFLYBY_END_MSG}`,\n                    cell_type: 'code',\n                    metadata: {}\n                }\n            });\n            this._context.model.cells.insert(pyflybyCellIndex, cell);\n            position = PYFLYBY_START_MSG.length + 1;\n        }\n        cell.metadata.set('tags', [PYFLYBY_CELL_TAG]);\n        return { cellIndex: pyflybyCellIndex, position };\n    }\n    /**\n     * Adds the import block to the appropriate cell at the appropriate\n     * location.\n     *\n     * @param importBlock - the import statement or block of import statements\n     */\n    _insertImport(imports) {\n        let p = null;\n        if (!_userWasNotified && !this._settings.get('disableNotification').user) {\n            p = this._launchDialog(imports);\n            _userWasNotified = true;\n        }\n        else {\n            p = Promise.resolve(imports);\n        }\n        // creates the cell for imports\n        this._findAndSetImportCoordinates();\n        return p;\n    }\n    _sendFormatCodeMsg(imports) {\n        const pyflybyCellIndex = ArrayExt.findFirstIndex(toArray(this._context.model.cells), (cell, index) => {\n            const tags = cell.metadata.get('tags');\n            return !!(tags && tags.indexOf(PYFLYBY_CELL_TAG) !== -1);\n        });\n        if (pyflybyCellIndex !== -1) {\n            const cellSource = this._context.model.cells\n                .get(pyflybyCellIndex)\n                .toJSON().source;\n            const comm = this._comms[PYFLYBY_COMMS.FORMAT_IMPORTS];\n            if (comm && !comm.isDisposed) {\n                comm.send({\n                    input_code: cellSource,\n                    imports: imports,\n                    type: PYFLYBY_COMMS.FORMAT_IMPORTS\n                });\n            }\n        }\n    }\n    _getCommMsgHandler() {\n        return async (msg) => {\n            const msgContent = msg.content.data;\n            switch (msgContent.type) {\n                case PYFLYBY_COMMS.MISSING_IMPORTS: {\n                    const itd = msgContent['missing_imports'];\n                    this._insertImport(itd).then(async (imports) => {\n                        // Acquire new lock but wait for previous lock to expire\n                        const currentLockId = this._lock.requestedLockCount;\n                        this._lock.enable(currentLockId + 1);\n                        await this._lock.promise[currentLockId];\n                        this._sendFormatCodeMsg(imports);\n                    });\n                    break;\n                }\n                case PYFLYBY_COMMS.FORMAT_IMPORTS: {\n                    this._formatImports(msgContent);\n                    this._lock.disable();\n                    break;\n                }\n                case PYFLYBY_COMMS.INIT: {\n                    this._initializeComms().catch(console.error);\n                    break;\n                }\n                default:\n                    break;\n            }\n        };\n    }\n    async _initializeComms() {\n        if (!this._sessionContext.session) {\n            return;\n        }\n        const { kernel } = this._sessionContext.session;\n        if (!kernel) {\n            return;\n        }\n        // Open the comm\n        const targetName = PYFLYBY_COMMS.MISSING_IMPORTS;\n        const comm = kernel.createComm(targetName);\n        comm.onMsg = this._getCommMsgHandler();\n        try {\n            comm.open();\n        }\n        catch (e) {\n            console.error(`Unable to open PYFLYBY comm - ${e}`);\n        }\n        const formatMsgComm = kernel.createComm(PYFLYBY_COMMS.FORMAT_IMPORTS);\n        formatMsgComm.onMsg = this._getCommMsgHandler();\n        formatMsgComm.onClose = (msg) => {\n            const commId = msg.content.comm_id;\n            delete this._comms[commId];\n        };\n        this._comms[PYFLYBY_COMMS.FORMAT_IMPORTS] = formatMsgComm;\n        try {\n            formatMsgComm.open();\n        }\n        catch (e) {\n            console.error(`Unable to open PYFLYBY comm - ${e}`);\n        }\n        kernel.registerCommTarget(PYFLYBY_COMMS.INIT, (comm, msg) => {\n            comm.onMsg = this._getCommMsgHandler();\n        });\n        return Promise.resolve();\n    }\n    _formatImports(msgData) {\n        const { formatted_code: formattedCode } = msgData;\n        const pyflybyCellIndex = ArrayExt.findFirstIndex(toArray(this._context.model.cells), (cell, index) => {\n            const tags = cell.metadata.get('tags');\n            return !!(tags && tags.indexOf(PYFLYBY_CELL_TAG) !== -1);\n        });\n        if (pyflybyCellIndex !== -1) {\n            const cell = this._context.model.cells.get(pyflybyCellIndex);\n            cell.value.remove(0, cell.value.text.length);\n            cell.value.insert(0, formattedCode);\n        }\n    }\n    async _handleKernelChange(sender, kernelChangedArgs) {\n        return await this._initializeComms();\n    }\n    _handleKernelStatusChange(sender, args) {\n        if (args === 'restarting') {\n            return this._initializeComms();\n        }\n        return null;\n    }\n}\n/**\n * An extension that adds pyflyby integration to a notebook widget\n */\nclass PyflyByWidgetExtension {\n    constructor(settingRegistry) {\n        this._settingRegistry = null;\n        // get a reference to the settings registry\n        // This is shared between all notebooks. I.e. not possible to\n        // have different pyflyby settings for different notebooks\n        this._settingRegistry = settingRegistry;\n        this._loadSettings().catch(console.error);\n    }\n    async _loadSettings() {\n        try {\n            await this._settingRegistry.load('@deshaw/jupyterlab-pyflyby:plugin');\n            log('Successfully loaded PYFLYBY extension settings');\n        }\n        catch (e) {\n            console.error('Settings could not be loaded');\n        }\n    }\n    createNew(panel, context) {\n        return new PyflyByWidget(context, panel, this._settingRegistry);\n    }\n}\nasync function isPyflybyInstalled() {\n    const pyflybyStatus = await requestAPI('pyflyby-status');\n    return pyflybyStatus.status;\n}\nasync function installPyflyby() {\n    try {\n        await requestAPI('install-pyflyby', { method: 'POST' });\n    }\n    catch (err) {\n        const errMsg = await err.json();\n        console.error(errMsg.result);\n    }\n}\nasync function disableJupyterlabPyflyby(registry) {\n    try {\n        await requestAPI('disable-pyflyby', {\n            method: 'POST',\n            mode: 'cors',\n            cache: 'no-cache',\n            credentials: 'include',\n            headers: { 'Content-type': 'application/x-www-form-urlencoded' },\n            body: new URLSearchParams('installDialogDisplayed=true')\n        });\n    }\n    catch (err) {\n        const errMsg = await err.json();\n        console.error(errMsg.result);\n    }\n    await registry.reload('@deshaw/jupyterlab-pyflyby:plugin');\n}\nconst installationBody = (React.createElement(\"div\", null,\n    React.createElement(\"p\", null,\n        \"To use @deshaw/jupyterlab-pyflyby,\",\n        ' ',\n        React.createElement(\"a\", { href: \"https://github.com/deshaw/pyflyby/blob/master/README.rst\", style: { color: '#0000EE' }, target: \"_blank\", rel: \"noopener noreferrer\" }, \"pyflyby\"),\n        ' ',\n        \"ipython extension needs to be installed.\"),\n    React.createElement(\"br\", null),\n    React.createElement(\"p\", null, \"Clicking on \\\"Install\\\" will run following command\"),\n    React.createElement(\"div\", { style: {\n            font: 'monospace',\n            color: '#ffffff',\n            backgroundColor: '#000000',\n            marginTop: '5px'\n        } }, \"$ py pyflyby.install_in_ipython_config_file\"),\n    React.createElement(\"br\", null)));\nconst extension = {\n    id: '@deshaw/jupyterlab-pyflyby:plugin',\n    autoStart: true,\n    requires: [ISettingRegistry],\n    activate: async function (app, registry) {\n        console.log('JupyterLab extension @deshaw/jupyterlab-pyflyby is activated!');\n        const settings = await registry.load('@deshaw/jupyterlab-pyflyby:plugin');\n        const enabled = settings.get('enabled').user || settings.get('enabled').composite;\n        const dialogDisplayedEarlier = settings.get('installDialogDisplayed').user;\n        if (enabled) {\n            const response = await isPyflybyInstalled();\n            if (response !== 'loaded') {\n                if (dialogDisplayedEarlier) {\n                    // Dialog to install pyflyby ipython extensions was displayed earlier,\n                    // install it since user is trying to use pyflyby by manually enabling\n                    // jupyterlab-pyflyby\n                    await installPyflyby();\n                }\n                else {\n                    const result = await showDialog({\n                        title: 'Installation required',\n                        body: installationBody,\n                        buttons: [\n                            Dialog.okButton({\n                                label: 'Install'\n                            }),\n                            Dialog.cancelButton({ label: 'Cancel', displayType: 'default' })\n                        ],\n                        defaultButton: 0\n                    });\n                    result.button.accept\n                        ? await installPyflyby()\n                        : await disableJupyterlabPyflyby(registry);\n                }\n            }\n        }\n        app.docRegistry.addWidgetExtension('Notebook', new PyflyByWidgetExtension(registry));\n    }\n};\nexport default extension;\n"],"sourceRoot":""}