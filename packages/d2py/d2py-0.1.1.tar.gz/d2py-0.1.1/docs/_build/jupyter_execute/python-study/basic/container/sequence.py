#!/usr/bin/env python
# coding: utf-8

# # 序列
# 
# `序列` 
# :   每个元素可以是任何类型（也可以是序列），每个元素被分配一个序号（从 `0` 开始）。序号，也叫索引，表示元素的位置。
# 
# Python 中的常用序列有：元组，列表，字符串，字节串，{class}`range` 对象等。
# 
# ```{admonition} 元组和列表的本质区别
# 列表是可以修改的而元组则不能。
# ```
# 
# ## 序列的基本操作
# 
# 以元组为例。
# 
# ### 索引
# 
# 索引，类似于获取数学中集合的元素的操作：返回序列中的元素。
# 
# ```{code-block}
# 序列[索引编号]
# ```
# 
# 示例：

# In[1]:


a = (1, 2, 3, 4)
a[0] # 获取列表 a 的第一个元素


# In[2]:


a[-2] # 获取列表 a 的倒数第二个元素


# ### 切片
# 
# 切片，类似获取数学中集合的子集的操作。返回子序列。
# 
# 使用方法：
# 
# ```{code-block}
# 序列[开始编号:结束编号后一个:步长]
# ```
# 
# `步长` 若为 `1`，可以省略：

# In[3]:


a = (1, 2, 3, 4, 5)
a[1:3] # 获取 a 的子列表 [a[1], a[2]]


# In[4]:


a[1:-1] # 获取 a 除去首尾元素的组成的子列表


# In[5]:


a[1:] # 获取 a 除去首元素的组成的子列表


# In[6]:


a[:-1] # 获取 a 除去末尾元素的组成的子列表


# In[7]:


a[:] # 获取 a 的一个副本（浅拷贝）


# ### 序列 `+`
# 
# 序列 `+` 用于同类型的序列的拼接：
# 
# ```{code-block}
# 序列 + 序列
# ```
# 类似于
# 
# ```{code-block}
# 一篮苹果 + 一篮香蕉 = 两篮水果
# ```
# 
# 使用 Python 表示：

# In[9]:


一篮苹果 = ('苹果1', '苹果2')
一篮香蕉 = ('香蕉1', '香蕉2', '香蕉3')

两篮水果 = 一篮苹果 + 一篮香蕉
两篮水果


# `+`  不会改变原有的序列：

# In[10]:


一篮苹果 # 查看有没有改变


# ### 序列 `*`
# 
# 序列 `*` 使用方法：
# 
# ```{code-block}
# 序列 * n
# ```
# 
# 表示将序列的元素按照原有顺序重复 `n` 次。 
# 
# 类似于：
# 
# ```{code-block}
# 一箱苹果 * n = n 箱苹果
# ```
# 
# Python 写作：

# In[11]:


一箱苹果 = ('苹果1', '苹果2')
两箱苹果 = 一箱苹果 * 2


# ```{note}
# 这个比喻并不恰当，因为，不可能存在两箱完全相同的苹果。这个例子仅仅是为了说明序列乘法的，大家不用考虑细节。
# ```
# 
# ### `index` 方法
# 
# 返回某个元素的索引，如若此元素不存在，则会引发异常。

# In[1]:


a = [1, 2, 3, 45, 5, 45, 7, 84]
a.index(45)


# ### `in`
# 
# `in`，类似于判断某个元素是否属于某个集合，并返回判断结果。
# 
# 使用方法：
# 
# ```{code-block}
# a in 序列A
# ```
# 
# 若 $a\in A$，则返回逻辑真值 {data}`True`，否则返回逻辑假值 {data}`False`。
# 
# ### 序列的长度，最大值，最小值
# 
# `len`、`max`、`min` 分别返回序列的长度，最大值，最小值。使用方法：
# 
# ```{code-block}
# len(序列)
# max(序列)
# min(序列)
# ```
# 
# ## 可变序列
# 
# 借由赋值语句可以对可变序列进行修改。
# 
# 下面仍然以列表 `a` 为例。

# In[12]:


a = [1, 2, 3, 4]


# In[13]:


a[0] = 2 # 修改 `a` 的首位元素
a


# In[14]:


a[1:3] = [5, 6] # 修改 `a` 的第 2、3 元素，即修改 `a` 的子集
a 


# In[15]:


a[1:3] = '' # 删除 `a` 的第 2、3 元素
a


# In[16]:


a[0:0] = [99, 88] # 在 `a` 的首位插入新的元素
a


# In[17]:


a[1:3] = list('hello') # 替换 `a` 的第 2、3 元素
a


# In[18]:


del a[0] # 显式删除 `a` 的首位元素


# In[19]:


a # 查看此时 a 的值


# In[20]:


del a[:3] # 显式删除 `a` 的前 3 项
a 


# ## 列表方法
# 
# 调用对象的方法：
# 
# ```{code-block}
# 对象.方法(参数)
# ```
# 
# ### `append` 方法
# 
# `list.append(x)` ~ `a[len(a):] = [x]`

# In[21]:


a = [1, 2, 3]
# 可以在列表的末尾追加新的元素
a.append(4)
a


# In[22]:


# 列表的末尾追加新的元素可以是其他对象，包括列表
a.append([1, 5, 'fr'])
a


# ### `count` 方法
#      
# 查看某个元素在列表中出现的次数：

# In[23]:


a = [1, 2, 3, 4, 1, 2]
a.count(1) # 计算 `1` 在 `a` 中出现的次数


# ### `extend` 方法
# 
# `list.extend(iterable)` ~ `a[len(a):] = iterable`
# 
# 使用其他列表拓展原有列表，其他列表的元素被添加到原有列表的末尾：
# 

# In[24]:


a = [1, 2, 3]
a.extend([4, 5, 6])
a


# ### `insert` 方法
# 
# 在指定位置插入元素。第一个参数是插入元素的索引，因此，`a.insert(0, x)` 在列表开头插入元素， `a.insert(len(a), x)` 等同于 `a.append(x)`。
# 
# 在序列的某个位置插入一个元素：

# In[26]:


a = [1, 2, 3, 4]
a.insert(2, 'hello')
a


# In[27]:


a.insert(20, 'world')  # 20 号位置不存在，直接插到列表末尾
a


# ### `pop` 方法
# 
# 移除列表某个位置的元素并返回该元素，如若没有指定要移除元素的位置，则默认移除末项。

# In[28]:


a = [1, 2, 3, 4]
last = a.pop()


# In[29]:


a # 最后的元素被移除


# In[30]:


first = a.pop(0) # 移除首位元素
a 


# ### `remove` 方法
# 
# 移除序列中第一个与参数匹配的元素：

# In[31]:


a = [1, 2, 88, 3, 4, 88, 2]
a.remove(88)
a


# ### `reverse` 方法
# 
# 将列表改为倒序：

# In[32]:


a = [1, 2, 3, 4, 2, 5, 3]
a.reverse()
a


# ### `sort` 方法
# 
# 默认为升序：

# In[33]:


a = [4, 6, 2, 1, 7, 9, 6]
a.sort()
a


# `sort` 可以传入参数：
# 
# - `key` 用来为每个元素提取比较值（默认值为 `None`）；
# - `reverse` 为 `True` 时是反序（默认值为 `False`）。

# In[34]:


names = ['Judy', 'Perter', 'Perkins']
names.sort(key=len)
names


# ## 不可变变序列
# 
# **不可变变序列** 是指元组的每个元素指向的引用永远不变。
# 
# 下面以元组为例说明。
# 
# ```{note}
# 输出时，元组都要由圆括号标注，这样才能正确地解释嵌套元组。输入时，圆括号可有可无，不过经常是必须的（如果元组是更大的表达式的一部分）。不允许为元组中的单个元素赋值，当然，可以创建含列表等可变对象的元组。
# ```

# In[35]:


b = ('python', '20150101', ['a', 'b'])
b


# 如果修改 `b` 的元素，则会触发异常：

# In[36]:


del b[0]


# 但是元组内的元素则不受此限制：

# In[37]:


b2 = b[2] # 取出 `b` 的第 3 个元素
b2.append('d') # 修改 b2
b # 可以看到 b 的第 3 个元素被修改了，这是因为 b2 是可变的


# 构造 0 个或 1 个元素的元组比较特殊：为了适应这种情况，对句法有一些额外的改变。用一对空圆括号就可以创建空元组；只有一个元素的元组可以通过在这个元素后添加逗号来构建（圆括号里只有一个值的话不够明确）。丑陋，但是有效。例如：

# In[4]:


empty = ()
singleton = 'hello',    # 注意结尾的逗号
empty, len(empty), singleton, len(singleton)


# ## 元组打包和序列解包
# 
# 语句 `t = 12345, 54321, 'hello!'` 是 **元组打包** 的例子：值 `12345`、 `54321` 和 `'hello!'` 一起被打包进元组。逆操作也可以：
# 
# ```python
# x, y, z = t
# ```
# 
# 称之为 **序列解包**。适用于右侧的任何序列。序列解包时，左侧变量与右侧序列元素的数量应相等。
# 
# ```{hint}
# 多重赋值其实只是元组打包和序列解包的组合。
# ```

# ## 推导式
# 
# 元组和列表支持推导式。
# 
# ## 序列解包
# 
# 
