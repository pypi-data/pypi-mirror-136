##################### generated by xml-casa (v2) from synthesisutils.xml ############
##################### 3af6f8f8235273e6d3c5c9c9914cbef3 ##############################
from __future__ import absolute_import 
from .__casac__ import synthesisutils as _synthesisutils

from .platform import str_encode as _str_ec
from .platform import str_decode as _str_dc
from .platform import dict_encode as _dict_ec
from .platform import dict_decode as _dict_dc
from .platform import dict_encode as _quant_ec
from .platform import dict_decode as _quant_dc
from .platform import encode as _any_ec
from .platform import decode as _any_dc
#from .errors import create_error_string
from .typecheck import CasaValidator as _validator
_pc = _validator( )
from .coercetype import coerce as _coerce
from .synthesisimstore import synthesisimstore as _wrap_synthesisimstore

class synthesisutils:
    _info_group_ = """synthesisutils"""
    _info_desc_ = """tool for synthesis imaging"""
    ### self
    def __init__(self, *args, **kwargs):
        """This is used to construct {tt synthesisutils} tool.
        """
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _synthesisutils()

    def contdatapartition(self, selpars={ }, npart=int(1)):
        """
        """
        return _dict_dc(self._swigobj.contdatapartition(_dict_ec(selpars), npart))

    def advisechansel(self, freqstart=[ ], freqend=[ ], freqstep=[ ], freqframe='LSRK', ephemtable='', msname='', fieldid=int(0), getfreqrange=False, spwselection=''):
        """It is a helper function, for cube imaging, that allows you to
        determine the spectral window data selection you may need to cover a
        given range of frequencies.
        
        In the mode with getfreqrange=False, the freqstep can be used (i.e., set to the channel width) to achieve the extra padding needed for data selection at the beginning and end of the desired cube range in order to retrieve all channels that will potentially contribute to the edge channels of the cube (to maximize S/N). If freqstep is not specified, it is taken as zero, and the output channel range will typically be slightly smaller.
        
        The meaning of freqframe parameter is dependent on the value of getfreqrange.
        When getfreqrange=False, frequency parameters are considered as input parameters that are known to be in the frame specified by freqframe; but when getfreqrange=True, the frequency parameters are output parameters that will be determined in the frame specified by freqframe. In the former case, the frequencies will be converted to the frame of the data as a function of time in order to locate which channels match.
        
        You need to specify the field_id for which this calculation is
        being done.
        
        If the parameter {tt getfreqrange=True} then the reverse is requested. You set {tt spwselection} to be the range of data selection you want to use and you'll get the range of frequency covered in the frame you set. The freqstart and freqend output values correspond to the frequency of the extreme edges of the requested channel range.
        Inputs
        ----------------
        freqstart
        Begining of frequency range
        allowed:  double, string, quantity
        example: freqstart='1.0GHz'
        Default:
        ----------------
        freqend
        End of frequency range
        allowed:  double, string, quantity
        example: freqend='2.0GHz'
        Default:''
        -----------------
        freqstep
        spectral channel resolution of intended image
        allowed:  double, string, quantity
        example: freqstep='1.0MHz'
        Default:''
        -----------------
        freqframe
        frame in which frequency is being expressed in other parameters. For solar system  moving sources if the frame of the source is intended then this parameter can be 'SOURCE'
        allowed : one of the following strings 'LSRK', 'LSRD', 'BARY', 'GEO', 'TOPO', 'GALACTO', 'LGROUP','CMB', 'SOURCE'
        Default: 'LSRK'
        ----------------
        msname
        name of a valid measurement set.
        allowed: string
        Default: ''
        -----------------
        ephemtable
        when freqframe='SOURCE' this parameter is used
        name of a valid ephemeris table or 'TRACKFIELD' to use the ephemeris table attached to the FIELD subtable of the ms or one of the following solar system object: 'MERCURY', 'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS', 'NEPTUNE', 'PLUTO', 'SUN', 'MOON'
        allowed: string
        Default: ''
        -----------------
        fieldid
        fieldid to use (needed to get the direction on the sky for any spectral frame conversion)
        allowed: integer
        Default: 0
        -------------------
        getfreqrange
        if set then freqrange is returned in the frame requested for the data selected
        allowed: bool
        Default: False
        -----------------
        spwselection
        if getfreqrange=True then this is needed to find the range of frequency in the frame requested. It should have the spectral window selection syntax as defined in the msselection (Casa memo 3)
        allowed: string
        Default: ''
        
        Example 1
        In this example, we are interested in an image cube which span 20.0682GHz to 20.1982 in LSRK  which will have a channel resolution of 3.9MHz. The field we are interested the one with fieldid=4
        
        #############################
        >>> from casatools import synthesisutils
        >>> syut=synthesisutils()
        >>> syut.advisechansel(freqstart="20.0682GHz", freqend="20.1982GHz", freqstep="3.9kHz", freqframe="LSRK", msname="test1.ms")
        {"nchan": array([109,  23], dtype=int32),  "spw": array([4, 5], dtype=int32),
        "start": array([19,  0], dtype=int32)}
        # implies 108 channels of spw 4 starting channel 19 and 23 channels of spw 5 starting at channel 0 would contribute data to the frequency range under consideration
        #############################
        
        Example 2
        
        To determine what is the frequency range in a given frame is covered by a given spwselection of the ms
        
        ##############
        >>> syut.advisechansel(msname="test3.ms", freqframe="LSRK", getfreqrange=True, spwselection="0:20~210")
        
        {"freqend": {"unit": "Hz", "value": 362746224619.3091}, "freqstart": {"unit": "Hz", "value": 362512788988.5036}}
        
        ##############
        
        Example 3:
        
        Same as Example 1 but with a solar system moving source and the frequency range provided is in the frame of the source. We are using the ephemeris table attached to the FIELD subtable of the ms.
        
        ##########
        >>> syut.advisechansel(msname="uid___A002_Xc05f54_X142a_target.spw31.contsub.ms", freqstart="362.5145206GHz", freqend="362.7476643GHz", freqstep="122.064714kHz", fieldid=3, freqframe="SOURCE", ephemtable="TRACKFIELD")
        ###########
        Now one can do the same with a valid ephemeris table
        ###########
        >>> syut.advisechansel(msname="uid___A002_Xc05f54_X142a_target.spw31.contsub.ms", freqstart="362.5145206GHz", freqend="362.7476643GHz", freqstep="122.064714kHz", fieldid=3, freqframe="SOURCE", ephemtable="EPHEM0_Titan_57889.1.tab")
        ###########
        
        Or if we want it in the frame of a solar system source known by casa, e.g "SATURN"
        ############
        >>> syut.advisechansel(msname="uid___A002_Xc05f54_X142a_target.spw31.contsub.ms", freqstart="362.5145206GHz", freqend="362.7476643GHz", freqstep="122.064714kHz", fieldid=3, freqframe="SOURCE", ephemtable="SATURN")
        ############
        
        Example 4:
        
        Same as Example 2  but with a solar system moving source and the frequency range we want to find is in the frame of the source.
        
        ############
        >>> syut.advisechansel(msname="uid___A002_Xc05f54_X142a_target.spw31.contsub.ms", fieldid=3, freqframe="SOURCE", ephemtable="TRACKFIELD", getfreqrange=True, spwselection="31:9~1919")
        #############
        similarly if we want it in the frame of a solar system source known casa e.g saturn
        #############
        >>> syut.advisechansel(msname="uid___A002_Xc05f54_X142a_target.spw31.contsub.ms", fieldid=3, freqframe="SOURCE", ephemtable="SATURN", getfreqrange=True, spwselection="31:9~1919")
        #############
        """
        return _dict_dc(self._swigobj.advisechansel(_any_ec(freqstart), _any_ec(freqend), _any_ec(freqstep), _str_ec(freqframe), _str_ec(ephemtable), _str_ec(msname), fieldid, getfreqrange, _str_ec(spwselection)))

    def cubedatapartition(self, selpars={ }, npart=int(1), fstart=[ ], fend=[ ], frame='LSRK'):
        """returns a dictionary with data spectral parttiion that maps  data  to  nparts
        of the input range frequency... usually to be used for doing data selection
        when imaging a cube from fstart to fend in npart subcubes
        """
        return _dict_dc(self._swigobj.cubedatapartition(_dict_ec(selpars), npart, _any_ec(fstart), _any_ec(fend), _str_ec(frame)))

    def cubeimagepartition(self, impars={ }, npart=int(1)):
        """
        """
        return _dict_dc(self._swigobj.cubeimagepartition(_dict_ec(impars), npart))

    def cubedataimagepartition(self, selpars={ }, incsys={ }, npart=int(1), nchannel=int(1)):
        """
        """
        return _dict_dc(self._swigobj.cubedataimagepartition(_dict_ec(selpars), _dict_ec(incsys), npart, nchannel))

    def checkselectionparams(self, selpars={ }):
        """
        """
        return _dict_dc(self._swigobj.checkselectionparams(_dict_ec(selpars)))

    def checkimageparams(self, impars={ }):
        """
        """
        return _dict_dc(self._swigobj.checkimageparams(_dict_ec(impars)))

    def checkgridparams(self, gridpars={ }):
        """
        """
        return _dict_dc(self._swigobj.checkgridparams(_dict_ec(gridpars)))

    def updateimpars(self, impars={ }):
        """
        """
        return _dict_dc(self._swigobj.updateimpars(_dict_ec(impars)))

    def getOptimumSize(self, size=int(100)):
        """
        """
        return self._swigobj.getOptimumSize(size)

    def fitPsfBeam(self, imagename='', nterms=int(1), psfcutoff=float(0.35)):
        """
        """
        return self._swigobj.fitPsfBeam(_str_ec(imagename), nterms, psfcutoff)

    def done(self):
        """
        """
        return self._swigobj.done()

