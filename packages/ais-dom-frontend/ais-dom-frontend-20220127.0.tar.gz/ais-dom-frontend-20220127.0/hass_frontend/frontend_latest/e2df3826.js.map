{"version":3,"file":"e2df3826.js","mappings":";;;AA0DA;AACA;;AAEA;;;AAIA;AACA;AACA;AAOA;;;AAaA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAQA;;;AAIA;;AAQA;;;AAaA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAKA;;;;ACrJA;;AC0UA;;AAKA;AAYA;AAEA;AACA;AAEA;AAOA;AAKA;AACA;AAEA;AACA;AACA;AACA;;AAEA;;;AAIA;AAGA;;;AAGA;AAOA;AAEA;AACA;AAEA;;;;AAOA;AACA;;;AAKA;;AASA;AACA;AACA;AACA;;;AAGA;;;;;AA9VA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA","sources":["webpack://home-assistant-frontend/mwc-circular-progress-base.ts","webpack://home-assistant-frontend/./src/components/ha-circular-progress.ts","webpack://home-assistant-frontend/./src/panels/lovelace/cards/hui-area-card.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport {ariaProperty} from '@material/mwc-base/aria-property';\nimport {html, LitElement, TemplateResult} from 'lit';\nimport {property} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {ifDefined} from 'lit/directives/if-defined.js';\nimport {styleMap} from 'lit/directives/style-map.js';\n\n/** @soyCompatible */\nexport class CircularProgressBase extends LitElement {\n  @property({type: Boolean, reflect: true}) indeterminate = false;\n\n  @property({type: Number, reflect: true}) progress = 0;\n\n  @property({type: Number, reflect: true}) density = 0;\n\n  @property({type: Boolean, reflect: true}) closed = false;\n\n  /** @soyPrefixAttribute */\n  @ariaProperty\n  @property({type: String, attribute: 'aria-label'})\n  ariaLabel!: string\n\n  open() {\n    this.closed = false;\n  }\n\n  close() {\n    this.closed = true;\n  }\n\n  /**\n   * @soyTemplate\n   */\n  protected override render(): TemplateResult {\n    /** @classMap */\n    const classes = {\n      'mdc-circular-progress--closed': this.closed,\n      'mdc-circular-progress--indeterminate': this.indeterminate,\n    };\n\n    const containerSideLength = 48 + this.density * 4;\n    /** @styleMap */\n    const styles = {\n      'width': `${containerSideLength}px`,\n      'height': `${containerSideLength}px`,\n    };\n\n    return html`\n      <div\n        class=\"mdc-circular-progress ${classMap(classes)}\"\n        style=\"${styleMap(styles)}\"\n        role=\"progressbar\"\n        aria-label=\"${ifDefined(this.ariaLabel)}\"\n        aria-valuemin=\"0\"\n        aria-valuemax=\"1\"\n        aria-valuenow=\"${\n        ifDefined(this.indeterminate ? undefined : this.progress)}\">\n        ${this.renderDeterminateContainer()}\n        ${this.renderIndeterminateContainer()}\n      </div>`;\n  }\n\n  /**\n   * @soyTemplate\n   */\n  protected renderDeterminateContainer(): TemplateResult {\n    const sideLength = 48 + this.density * 4;\n    const center = sideLength / 2;\n    const circleRadius = this.density >= -3 ? 18 + this.density * 11 / 6 :\n                                              12.5 + (this.density + 3) * 5 / 4;\n    const circumference = 2 * 3.1415926 * circleRadius;\n    const determinateStrokeDashOffset = (1 - this.progress) * circumference;\n    const strokeWidth = this.density >= -3 ? 4 + this.density * (1 / 3) :\n                                             3 + (this.density + 3) * (1 / 6);\n\n    return html`\n      <div class=\"mdc-circular-progress__determinate-container\">\n        <svg class=\"mdc-circular-progress__determinate-circle-graphic\"\n             viewBox=\"0 0 ${sideLength} ${sideLength}\">\n          <circle class=\"mdc-circular-progress__determinate-track\"\n                  cx=\"${center}\" cy=\"${center}\" r=\"${circleRadius}\"\n                  stroke-width=\"${strokeWidth}\"></circle>\n          <circle class=\"mdc-circular-progress__determinate-circle\"\n                  cx=\"${center}\" cy=\"${center}\" r=\"${circleRadius}\"\n                  stroke-dasharray=\"${2 * 3.1415926 * circleRadius}\"\n                  stroke-dashoffset=\"${determinateStrokeDashOffset}\"\n                  stroke-width=\"${strokeWidth}\"></circle>\n        </svg>\n      </div>`;\n  }\n\n  /**\n   * @soyTemplate\n   */\n  protected renderIndeterminateContainer(): TemplateResult {\n    return html`\n      <div class=\"mdc-circular-progress__indeterminate-container\">\n        <div class=\"mdc-circular-progress__spinner-layer\">\n          ${this.renderIndeterminateSpinnerLayer()}\n        </div>\n      </div>`;\n  }\n\n  /**\n   * @soyTemplate\n   */\n  protected renderIndeterminateSpinnerLayer(): TemplateResult {\n    const sideLength = 48 + this.density * 4;\n    const center = sideLength / 2;\n    const circleRadius = this.density >= -3 ? 18 + this.density * 11 / 6 :\n                                              12.5 + (this.density + 3) * 5 / 4;\n    const circumference = 2 * 3.1415926 * circleRadius;\n    const halfCircumference = 0.5 * circumference;\n    const strokeWidth = this.density >= -3 ? 4 + this.density * (1 / 3) :\n                                             3 + (this.density + 3) * (1 / 6);\n\n    return html`\n        <div class=\"mdc-circular-progress__circle-clipper mdc-circular-progress__circle-left\">\n          <svg class=\"mdc-circular-progress__indeterminate-circle-graphic\"\n               viewBox=\"0 0 ${sideLength} ${sideLength}\">\n            <circle cx=\"${center}\" cy=\"${center}\" r=\"${circleRadius}\"\n                    stroke-dasharray=\"${circumference}\"\n                    stroke-dashoffset=\"${halfCircumference}\"\n                    stroke-width=\"${strokeWidth}\"></circle>\n          </svg>\n        </div>\n        <div class=\"mdc-circular-progress__gap-patch\">\n          <svg class=\"mdc-circular-progress__indeterminate-circle-graphic\"\n               viewBox=\"0 0 ${sideLength} ${sideLength}\">\n            <circle cx=\"${center}\" cy=\"${center}\" r=\"${circleRadius}\"\n                    stroke-dasharray=\"${circumference}\"\n                    stroke-dashoffset=\"${halfCircumference}\"\n                    stroke-width=\"${strokeWidth * 0.8}\"></circle>\n          </svg>\n        </div>\n        <div class=\"mdc-circular-progress__circle-clipper mdc-circular-progress__circle-right\">\n          <svg class=\"mdc-circular-progress__indeterminate-circle-graphic\"\n               viewBox=\"0 0 ${sideLength} ${sideLength}\">\n            <circle cx=\"${center}\" cy=\"${center}\" r=\"${circleRadius}\"\n                    stroke-dasharray=\"${circumference}\"\n                    stroke-dashoffset=\"${halfCircumference}\"\n                    stroke-width=\"${strokeWidth}\"></circle>\n          </svg>\n        </div>`;\n  }\n\n  override update(changedProperties: Map<string, string>) {\n    super.update(changedProperties);\n\n    // Bound progress value in interval [0, 1].\n    if (changedProperties.has('progress')) {\n      if (this.progress > 1) {\n        this.progress = 1;\n      }\n\n      if (this.progress < 0) {\n        this.progress = 0;\n      }\n    }\n  }\n}\n","import { CircularProgress } from \"@material/mwc-circular-progress\";\nimport { CSSResultGroup, css } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-circular-progress\")\n// @ts-ignore\nexport class HaCircularProgress extends CircularProgress {\n  @property({ type: Boolean })\n  public active = false;\n\n  @property()\n  public alt = \"Loading\";\n\n  @property()\n  public size: \"tiny\" | \"small\" | \"medium\" | \"large\" = \"medium\";\n\n  // @ts-ignore\n  public set density(_) {\n    // just a dummy\n  }\n\n  public get density() {\n    switch (this.size) {\n      case \"tiny\":\n        return -8;\n      case \"small\":\n        return -5;\n      case \"medium\":\n        return 0;\n      case \"large\":\n        return 5;\n      default:\n        return 0;\n    }\n  }\n\n  // @ts-ignore\n  public set indeterminate(_) {\n    // just a dummy\n  }\n\n  public get indeterminate() {\n    return this.active;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      super.styles,\n      css`\n        :host {\n          overflow: hidden;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-circular-progress\": HaCircularProgress;\n  }\n}\n","import \"@material/mwc-ripple\";\nimport {\n  mdiLightbulbMultiple,\n  mdiLightbulbMultipleOff,\n  mdiRun,\n  mdiToggleSwitch,\n  mdiToggleSwitchOff,\n  mdiWaterPercent,\n} from \"@mdi/js\";\nimport type { HassEntity, UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport { STATES_OFF } from \"../../../common/const\";\nimport { applyThemesOnElement } from \"../../../common/dom/apply_themes_on_element\";\nimport { computeDomain } from \"../../../common/entity/compute_domain\";\nimport { domainIcon } from \"../../../common/entity/domain_icon\";\nimport { navigate } from \"../../../common/navigate\";\nimport { formatNumber } from \"../../../common/number/format_number\";\nimport { subscribeOne } from \"../../../common/util/subscribe-one\";\nimport \"../../../components/entity/state-badge\";\nimport \"../../../components/ha-card\";\nimport \"../../../components/ha-icon-button\";\nimport \"../../../components/ha-state-icon\";\nimport \"../../../components/ha-svg-icon\";\nimport \"../components/hui-image\";\nimport {\n  AreaRegistryEntry,\n  subscribeAreaRegistry,\n} from \"../../../data/area_registry\";\nimport {\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../../../data/device_registry\";\nimport { UNAVAILABLE_STATES } from \"../../../data/entity\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n} from \"../../../data/entity_registry\";\nimport { forwardHaptic } from \"../../../data/haptics\";\nimport { SubscribeMixin } from \"../../../mixins/subscribe-mixin\";\nimport { HomeAssistant } from \"../../../types\";\nimport \"../components/hui-warning\";\nimport { LovelaceCard, LovelaceCardEditor } from \"../types\";\nimport { AreaCardConfig } from \"./types\";\n\nconst SENSOR_DOMAINS = [\"sensor\"];\n\nconst ALERT_DOMAINS = [\"binary_sensor\"];\n\nconst TOGGLE_DOMAINS = [\"light\", \"switch\", \"fan\"];\n\nconst OTHER_DOMAINS = [\"camera\"];\n\nconst DEVICE_CLASSES = {\n  sensor: [\"temperature\"],\n  binary_sensor: [\"motion\"],\n};\n\nconst DOMAIN_ICONS = {\n  light: { on: mdiLightbulbMultiple, off: mdiLightbulbMultipleOff },\n  switch: { on: mdiToggleSwitch, off: mdiToggleSwitchOff },\n  fan: { on: domainIcon(\"fan\"), off: domainIcon(\"fan\") },\n  sensor: { humidity: mdiWaterPercent },\n  binary_sensor: {\n    motion: mdiRun,\n  },\n};\n\n@customElement(\"hui-area-card\")\nexport class HuiAreaCard\n  extends SubscribeMixin(LitElement)\n  implements LovelaceCard\n{\n  public static async getConfigElement(): Promise<LovelaceCardEditor> {\n    await import(\"../editor/config-elements/hui-area-card-editor\");\n    return document.createElement(\"hui-area-card-editor\");\n  }\n\n  public static async getStubConfig(\n    hass: HomeAssistant\n  ): Promise<AreaCardConfig> {\n    const areas = await subscribeOne(hass.connection, subscribeAreaRegistry);\n    return { type: \"area\", area: areas[0]?.area_id || \"\" };\n  }\n\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _config?: AreaCardConfig;\n\n  @state() private _entities?: EntityRegistryEntry[];\n\n  @state() private _devices?: DeviceRegistryEntry[];\n\n  @state() private _areas?: AreaRegistryEntry[];\n\n  private _entitiesByDomain = memoizeOne(\n    (\n      areaId: string,\n      devicesInArea: Set<string>,\n      registryEntities: EntityRegistryEntry[],\n      states: HomeAssistant[\"states\"]\n    ) => {\n      const entitiesInArea = registryEntities\n        .filter(\n          (entry) =>\n            !entry.entity_category &&\n            (entry.area_id\n              ? entry.area_id === areaId\n              : entry.device_id && devicesInArea.has(entry.device_id))\n        )\n        .map((entry) => entry.entity_id);\n\n      const entitiesByDomain: { [domain: string]: HassEntity[] } = {};\n\n      for (const entity of entitiesInArea) {\n        const domain = computeDomain(entity);\n        if (\n          !TOGGLE_DOMAINS.includes(domain) &&\n          !SENSOR_DOMAINS.includes(domain) &&\n          !ALERT_DOMAINS.includes(domain) &&\n          !OTHER_DOMAINS.includes(domain)\n        ) {\n          continue;\n        }\n        const stateObj: HassEntity | undefined = states[entity];\n\n        if (!stateObj) {\n          continue;\n        }\n\n        if (\n          (SENSOR_DOMAINS.includes(domain) || ALERT_DOMAINS.includes(domain)) &&\n          !DEVICE_CLASSES[domain].includes(\n            stateObj.attributes.device_class || \"\"\n          )\n        ) {\n          continue;\n        }\n\n        if (!(domain in entitiesByDomain)) {\n          entitiesByDomain[domain] = [];\n        }\n        entitiesByDomain[domain].push(stateObj);\n      }\n\n      return entitiesByDomain;\n    }\n  );\n\n  private _isOn(domain: string, deviceClass?: string): boolean | undefined {\n    const entities = this._entitiesByDomain(\n      this._config!.area,\n      this._devicesInArea(this._config!.area, this._devices!),\n      this._entities!,\n      this.hass.states\n    )[domain];\n    if (!entities) {\n      return undefined;\n    }\n    return (\n      deviceClass\n        ? entities.filter(\n            (entity) => entity.attributes.device_class === deviceClass\n          )\n        : entities\n    ).some(\n      (entity) =>\n        !UNAVAILABLE_STATES.includes(entity.state) &&\n        !STATES_OFF.includes(entity.state)\n    );\n  }\n\n  private _average(domain: string, deviceClass?: string): string | undefined {\n    const entities = this._entitiesByDomain(\n      this._config!.area,\n      this._devicesInArea(this._config!.area, this._devices!),\n      this._entities!,\n      this.hass.states\n    )[domain].filter((entity) =>\n      deviceClass ? entity.attributes.device_class === deviceClass : true\n    );\n    if (!entities) {\n      return undefined;\n    }\n    let uom;\n    const values = entities.filter((entity) => {\n      if (\n        !entity.attributes.unit_of_measurement ||\n        isNaN(Number(entity.state))\n      ) {\n        return false;\n      }\n      if (!uom) {\n        uom = entity.attributes.unit_of_measurement;\n        return true;\n      }\n      return entity.attributes.unit_of_measurement === uom;\n    });\n    if (!values.length) {\n      return undefined;\n    }\n    const sum = values.reduce(\n      (total, entity) => total + Number(entity.state),\n      0\n    );\n    return `${formatNumber(sum / values.length, this.hass!.locale, {\n      maximumFractionDigits: 1,\n    })} ${uom}`;\n  }\n\n  private _area = memoizeOne(\n    (areaId: string | undefined, areas: AreaRegistryEntry[]) =>\n      areas.find((area) => area.area_id === areaId) || null\n  );\n\n  private _devicesInArea = memoizeOne(\n    (areaId: string | undefined, devices: DeviceRegistryEntry[]) =>\n      new Set(\n        areaId\n          ? devices\n              .filter((device) => device.area_id === areaId)\n              .map((device) => device.id)\n          : []\n      )\n  );\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeAreaRegistry(this.hass!.connection, (areas) => {\n        this._areas = areas;\n      }),\n      subscribeDeviceRegistry(this.hass!.connection, (devices) => {\n        this._devices = devices;\n      }),\n      subscribeEntityRegistry(this.hass!.connection, (entries) => {\n        this._entities = entries;\n      }),\n    ];\n  }\n\n  public getCardSize(): number {\n    return 3;\n  }\n\n  public setConfig(config: AreaCardConfig): void {\n    if (!config.area) {\n      throw new Error(\"Area Required\");\n    }\n\n    this._config = config;\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    if (changedProps.has(\"_config\") || !this._config) {\n      return true;\n    }\n\n    if (\n      changedProps.has(\"_devicesInArea\") ||\n      changedProps.has(\"_areas\") ||\n      changedProps.has(\"_entities\")\n    ) {\n      return true;\n    }\n\n    if (!changedProps.has(\"hass\")) {\n      return false;\n    }\n\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n    if (\n      !oldHass ||\n      oldHass.themes !== this.hass!.themes ||\n      oldHass.locale !== this.hass!.locale\n    ) {\n      return true;\n    }\n\n    if (\n      !this._devices ||\n      !this._devicesInArea(this._config.area, this._devices) ||\n      !this._entities\n    ) {\n      return false;\n    }\n\n    const entities = this._entitiesByDomain(\n      this._config.area,\n      this._devicesInArea(this._config.area, this._devices),\n      this._entities,\n      this.hass.states\n    );\n\n    for (const domainEntities of Object.values(entities)) {\n      for (const stateObj of domainEntities) {\n        if (oldHass!.states[stateObj.entity_id] !== stateObj) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  protected render(): TemplateResult {\n    if (\n      !this._config ||\n      !this.hass ||\n      !this._areas ||\n      !this._devices ||\n      !this._entities\n    ) {\n      return html``;\n    }\n\n    const entitiesByDomain = this._entitiesByDomain(\n      this._config.area,\n      this._devicesInArea(this._config.area, this._devices),\n      this._entities,\n      this.hass.states\n    );\n    const area = this._area(this._config.area, this._areas);\n\n    if (area === null) {\n      return html`\n        <hui-warning>\n          ${this.hass.localize(\"ui.card.area.area_not_found\")}\n        </hui-warning>\n      `;\n    }\n\n    const sensors: TemplateResult[] = [];\n    SENSOR_DOMAINS.forEach((domain) => {\n      if (!(domain in entitiesByDomain)) {\n        return;\n      }\n      DEVICE_CLASSES[domain].forEach((deviceClass) => {\n        if (\n          entitiesByDomain[domain].some(\n            (entity) => entity.attributes.device_class === deviceClass\n          )\n        ) {\n          sensors.push(html`\n            ${DOMAIN_ICONS[domain][deviceClass]\n              ? html`<ha-svg-icon\n                  .path=${DOMAIN_ICONS[domain][deviceClass]}\n                ></ha-svg-icon>`\n              : \"\"}\n            ${this._average(domain, deviceClass)}\n          `);\n        }\n      });\n    });\n\n    let cameraEntityId: string | undefined;\n    if (this._config.show_camera && \"camera\" in entitiesByDomain) {\n      cameraEntityId = entitiesByDomain.camera[0].entity_id;\n    }\n\n    return html`\n      <ha-card class=${area.picture || cameraEntityId ? \"image\" : \"\"}>\n        ${area.picture || cameraEntityId\n          ? html`<hui-image\n              .config=${this._config}\n              .hass=${this.hass}\n              .image=${area.picture ? area.picture : undefined}\n              .cameraImage=${cameraEntityId}\n              aspectRatio=\"16:9\"\n            ></hui-image>`\n          : \"\"}\n\n        <div\n          class=\"container ${classMap({\n            navigate: this._config.navigation_path !== undefined,\n          })}\"\n          @click=${this._handleNavigation}\n        >\n          <div class=\"alerts\">\n            ${ALERT_DOMAINS.map((domain) => {\n              if (!(domain in entitiesByDomain)) {\n                return \"\";\n              }\n              return DEVICE_CLASSES[domain].map((deviceClass) =>\n                this._isOn(domain, deviceClass)\n                  ? html`\n                      ${DOMAIN_ICONS[domain][deviceClass]\n                        ? html`<ha-svg-icon\n                            .path=${DOMAIN_ICONS[domain][deviceClass]}\n                          ></ha-svg-icon>`\n                        : \"\"}\n                    `\n                  : \"\"\n              );\n            })}\n          </div>\n          <div class=\"bottom\">\n            <div>\n              <div class=\"name\">${area.name}</div>\n              ${sensors.length\n                ? html`<div class=\"sensors\">${sensors}</div>`\n                : \"\"}\n            </div>\n            <div class=\"buttons\">\n              ${TOGGLE_DOMAINS.map((domain) => {\n                if (!(domain in entitiesByDomain)) {\n                  return \"\";\n                }\n\n                const on = this._isOn(domain)!;\n                return TOGGLE_DOMAINS.includes(domain)\n                  ? html`\n                      <ha-icon-button\n                        class=${on ? \"on\" : \"off\"}\n                        .path=${DOMAIN_ICONS[domain][on ? \"on\" : \"off\"]}\n                        .domain=${domain}\n                        @click=${this._toggle}\n                      >\n                      </ha-icon-button>\n                    `\n                  : \"\";\n              })}\n            </div>\n          </div>\n        </div>\n      </ha-card>\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    super.updated(changedProps);\n    if (!this._config || !this.hass) {\n      return;\n    }\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    const oldConfig = changedProps.get(\"_config\") as AreaCardConfig | undefined;\n\n    if (\n      (changedProps.has(\"hass\") &&\n        (!oldHass || oldHass.themes !== this.hass.themes)) ||\n      (changedProps.has(\"_config\") &&\n        (!oldConfig || oldConfig.theme !== this._config.theme))\n    ) {\n      applyThemesOnElement(this, this.hass.themes, this._config.theme);\n    }\n  }\n\n  private _handleNavigation() {\n    if (this._config!.navigation_path) {\n      navigate(this._config!.navigation_path);\n    }\n  }\n\n  private _toggle(ev: Event) {\n    ev.stopPropagation();\n    const domain = (ev.currentTarget as any).domain as string;\n    if (TOGGLE_DOMAINS.includes(domain)) {\n      this.hass.callService(\n        domain,\n        this._isOn(domain) ? \"turn_off\" : \"turn_on\",\n        undefined,\n        {\n          area_id: this._config!.area,\n        }\n      );\n    }\n    forwardHaptic(\"light\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        overflow: hidden;\n        position: relative;\n        padding-bottom: 56.25%;\n        background-size: cover;\n      }\n\n      ha-card.image {\n        padding-bottom: 0;\n      }\n\n      .container {\n        display: flex;\n        flex-direction: column;\n        justify-content: space-between;\n        position: absolute;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        background: linear-gradient(\n          0,\n          rgba(33, 33, 33, 0.9) 0%,\n          rgba(33, 33, 33, 0) 45%\n        );\n      }\n\n      ha-card:not(.image) .container::before {\n        position: absolute;\n        content: \"\";\n        width: 100%;\n        height: 100%;\n        background-color: var(--sidebar-selected-icon-color);\n        opacity: 0.12;\n      }\n\n      .sensors {\n        color: #e3e3e3;\n        font-size: 16px;\n        --mdc-icon-size: 24px;\n        opacity: 0.6;\n        margin-top: 8px;\n      }\n\n      .alerts {\n        padding: 16px;\n      }\n\n      .alerts ha-svg-icon {\n        background: var(--accent-color);\n        color: var(--text-accent-color, var(--text-primary-color));\n        padding: 8px;\n        border-radius: 50%;\n      }\n\n      .name {\n        color: white;\n        font-size: 24px;\n      }\n\n      .bottom {\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n        padding: 16px;\n      }\n\n      .navigate {\n        cursor: pointer;\n      }\n\n      ha-icon-button {\n        color: white;\n        background-color: var(--area-button-color, #727272b2);\n        border-radius: 50%;\n        margin-left: 8px;\n        --mdc-icon-button-size: 44px;\n      }\n      .on {\n        color: var(--paper-item-icon-active-color, #fdd835);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-area-card\": HuiAreaCard;\n  }\n}\n"],"names":[],"sourceRoot":""}